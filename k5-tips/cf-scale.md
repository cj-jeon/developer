# CFのインスタンスを簡単にスケールする方法

## CFでインスタンスをスケールする

CFに限らずPaaSを使うと、アプリケーションを利用する
ためのOS、実行環境、ミドルウェア等が用意され、
PaaS利用者のうち、所謂開発者は「アプリケーションを
動作させるための環境準備に作業時間を割かれることなく、
アプリケーション作成に専念できる」メリットが得られる
ことは広く知られているように思われます。

でも、実は運用管理者にとってもメリットがあることは
意外に知られていない気がします。
例えば、急にアプリケーションの利用率が上昇して、
急遽スケールしなければならなくなった場合、
もし従来のオンプレ環境やIaaSを利用して運用していた
なら、どんな作業が必要になるでしょう？

各作業の必要・不要を表にすると、こんな感じになります。

| 作業                             | IaaS |  CF  |
|:-------------------------------- |:----:|:----:|
| マシン調達                       | 必要 | 不要 |
| OSインストール                   | 必要 | 不要 |
| 実行環境インストール             | 必要 | 不要 |
| ミドルウェアインストール         | 必要 | 不要 |
| 新インスタンスの起動             | 必要 | 必要 |
| インスタンス同士のロードバランス | 必要 | 不要 |
| 新インスタンスの死活監視設定     | 必要 | 不要 |

CFを利用していた場合、オンプレ環境やIaaSを利用していた
場合に必要だったほとんどの作業を、1個のコマンドを
実行するだけで済ませることができます。

## スケールのコントロール方法

CFを利用してアプリケーションを動作させている場合、
動作させているアプリケーションのインスタンス数を、
コマンド一つで自在に増減できます。
実際にテストアプリケーションとCFのコマンドを使って、
確認してみましょう。

1. テストアプリケーションの作成

   以下のソースコードを使って、テストアプリケーション
   ”AppTest001”を作り、CFにデプロイします。
   AppTest001は、呼び出されると、”自分に割り付けられた
   IPアドレス”な文字列を返すアプリケーションです。
   CFへのログイン方法、テストアプリケーションのCFへの
   デプロイ方法は、「K5 CF チュートリアル」等を参照
   してください。

   ```
   package com.example;

   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;

   @SpringBootApplication
   @RestController
   public class HelloPwsApplication {

       @RequestMapping("/")
       String hello() {
           return System.getenv("CF_INSTANCE_ADDR");
       }

       public static void main(String[] args) {
           SpringApplication.run(HelloPwsApplication.class, args);
       }
   }
   ```

1. 状態確認（インスタンス数変更前）

   ”AppTest001”をCFにデプロイしたのち、アプリケーションの
   配備状態を確認するためのコマンド”cf apps”を実行すると
   以下のような応答が返ります。

   ```
   name        requested state instances   memory  disk    urls
   AppTest001  started         1/1         1G      1G      AppTest001.xxxx…
   ```

   instances が 1/1 なので、インスタンスが一つ起動
   されていることがわかります。

1. アプリケーション実行（インスタンス数変更前）

   この状態で、複数回AppTest001を呼び出すと、毎回同じIPアドレスの文字列が返ってきます。

   ```
   $ for i in `seq 1 10`; do curl http://AppTest001.xxxx…; done
   10.10.115.91:60224
   10.10.115.91:60224
   10.10.115.91:60224
   10.10.115.91:60224
   10.10.115.91:60224
   10.10.115.91:60224
   10.10.115.91:60224
   10.10.115.91:60224
   10.10.115.91:60224
   10.10.115.91:60224
   ```

1. インスタンス数変更

   ここで、AppTest001のインスタンス数を増やし、
   スケールアウトさせてみましょう。
   インスタンスの増減は、コマンド“cf scale”で、
   インスタンス数を指定するだけで実現できます。

   ```
   $ cf scale AppTest001 -i 4
   ```

1. 状態確認（インスタンス数変更後）

   この状態で、”cf apps”を実行すると以下のような
   応答が返り、インスタンスが4つに増えていることが
   確認できます。

   ```
   name        requested state instances   memory  disk    urls
   AppTest001  started         4/4         1G      1G      AppTest001.xxxx…
   ```

1. アプリケーション実行（インスタンス数変更後）

   この状態で、複数回AppTest001を呼び出すと、
   同じURLでアクセスしているにも関わらず、
   4種類の異なる毎IPアドレスの文字列が返ってきます。

   ```
   $ for i in `seq 1 10`; do curl http://AppTest001.xxxx…; done
   10.10.115.78:62878
   10.10.115.91:60224
   10.10.115.43:61547
   10.10.115.65:64587
   10.10.115.78:62878
   10.10.115.91:60224
   10.10.115.43:61547
   10.10.115.65:64587
   10.10.115.78:62878
   10.10.115.91:60224
   ```

## コマンド１つで簡単スケール操作

上記の例の通り、CFを利用して動作させたアプリケー
ションは、コマンド一つでスケールの増減が可能です。

スケールアウト用に増加したインスタンスと元から
存在するインスタンスは、自動的にロードバランシング
されます。
すべてのインスタンスは同じURLでのアクセスが保証され、
利用者からみた場合、アプリケーションが複数のインス
タンスで構成されているか否か意識せずに利用できます。

CF上でアプリケーションを動作させることで、アプリ
ケーションのスケールを変更しなければならなくなった
場合、運用管理者がかつて行う必要のあった多くの
作業を、CFが自動的に行ってくれることをわかって
いただけたと思います。
